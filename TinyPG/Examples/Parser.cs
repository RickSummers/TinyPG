// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

// Disable unused variable warnings which
// can happen during the parser generation.
#pragma warning disable 168


namespace TinyPG
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.USING_KEYWORD, TokenType.NAMESPACE_KEYWORD); // Option Rule
            if (tok.Type == TokenType.USING_KEYWORD
                || tok.Type == TokenType.NAMESPACE_KEYWORD)
            {
                ParseProgram(node); // NonTerminal Rule: Program
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseProgram(ParseNode parent) // NonTerminalSymbol: Program
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Program), "Program");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseUsings(node); // NonTerminal Rule: Usings

             // Concat Rule
            ParseNamespace(node); // NonTerminal Rule: Namespace

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Program

        private void ParseUsings(ParseNode parent) // NonTerminalSymbol: Usings
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Usings), "Usings");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.USING_KEYWORD); // ZeroOrMore Rule
            while (tok.Type == TokenType.USING_KEYWORD)
            {
                ParseUsingStatement(node); // NonTerminal Rule: UsingStatement
            tok = scanner.LookAhead(TokenType.USING_KEYWORD); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Usings

        private void ParseUsingStatement(ParseNode parent) // NonTerminalSymbol: UsingStatement
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.UsingStatement), "UsingStatement");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.USING_KEYWORD); // Terminal Rule: USING_KEYWORD
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.USING_KEYWORD) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.USING_KEYWORD.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAMESPACE_REFERENCE); // Terminal Rule: NAMESPACE_REFERENCE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAMESPACE_REFERENCE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAMESPACE_REFERENCE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOS); // Terminal Rule: EOS
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOS.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: UsingStatement

        private void ParseNamespace(ParseNode parent) // NonTerminalSymbol: Namespace
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Namespace), "Namespace");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.NAMESPACE_KEYWORD); // Terminal Rule: NAMESPACE_KEYWORD
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAMESPACE_KEYWORD) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAMESPACE_KEYWORD.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NAMESPACE_REFERENCE); // Terminal Rule: NAMESPACE_REFERENCE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NAMESPACE_REFERENCE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAMESPACE_REFERENCE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseNamespaceBody(node); // NonTerminal Rule: NamespaceBody

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Namespace

        private void ParseNamespaceBody(ParseNode parent) // NonTerminalSymbol: NamespaceBody
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NamespaceBody), "NamespaceBody");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BRACEOPEN); // Terminal Rule: BRACEOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACEOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACEOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            do { // OneOrMore Rule
                ParseClassDeclaration(node); // NonTerminal Rule: ClassDeclaration
                tok = scanner.LookAhead(TokenType.MODIFIER_KEYWORD, TokenType.PARTIAL_KEYWORD, TokenType.CLASS_KEYWORD); // OneOrMore Rule
            } while (tok.Type == TokenType.MODIFIER_KEYWORD
                || tok.Type == TokenType.PARTIAL_KEYWORD
                || tok.Type == TokenType.CLASS_KEYWORD); // OneOrMore Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACECLOSE); // Terminal Rule: BRACECLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACECLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACECLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: NamespaceBody

        private void ParseClassDeclaration(ParseNode parent) // NonTerminalSymbol: ClassDeclaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ClassDeclaration), "ClassDeclaration");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.MODIFIER_KEYWORD); // Option Rule
            if (tok.Type == TokenType.MODIFIER_KEYWORD)
            {
                tok = scanner.Scan(TokenType.MODIFIER_KEYWORD); // Terminal Rule: MODIFIER_KEYWORD
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.MODIFIER_KEYWORD) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODIFIER_KEYWORD.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.PARTIAL_KEYWORD); // Option Rule
            if (tok.Type == TokenType.PARTIAL_KEYWORD)
            {
                tok = scanner.Scan(TokenType.PARTIAL_KEYWORD); // Terminal Rule: PARTIAL_KEYWORD
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PARTIAL_KEYWORD) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARTIAL_KEYWORD.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.CLASS_KEYWORD); // Terminal Rule: CLASS_KEYWORD
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CLASS_KEYWORD) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLASS_KEYWORD.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.INHERIT); // Option Rule
            if (tok.Type == TokenType.INHERIT)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.INHERIT); // Terminal Rule: INHERIT
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.INHERIT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INHERIT.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.NAMESPACE_REFERENCE); // Terminal Rule: NAMESPACE_REFERENCE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.NAMESPACE_REFERENCE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NAMESPACE_REFERENCE.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            ParseClassBody(node); // NonTerminal Rule: ClassBody

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ClassDeclaration

        private void ParseClassBody(ParseNode parent) // NonTerminalSymbol: ClassBody
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ClassBody), "ClassBody");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BRACEOPEN); // Terminal Rule: BRACEOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACEOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACEOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            do { // OneOrMore Rule
                ParseDeclaration(node); // NonTerminal Rule: Declaration
                tok = scanner.LookAhead(TokenType.MODIFIER_KEYWORD, TokenType.TYPE, TokenType.IDENTIFIER); // OneOrMore Rule
            } while (tok.Type == TokenType.MODIFIER_KEYWORD
                || tok.Type == TokenType.TYPE
                || tok.Type == TokenType.IDENTIFIER); // OneOrMore Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACECLOSE); // Terminal Rule: BRACECLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACECLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACECLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ClassBody

        private void ParseDeclaration(ParseNode parent) // NonTerminalSymbol: Declaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Declaration), "Declaration");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.MODIFIER_KEYWORD); // Option Rule
            if (tok.Type == TokenType.MODIFIER_KEYWORD)
            {
                tok = scanner.Scan(TokenType.MODIFIER_KEYWORD); // Terminal Rule: MODIFIER_KEYWORD
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.MODIFIER_KEYWORD) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODIFIER_KEYWORD.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.TYPE); // Option Rule
            if (tok.Type == TokenType.TYPE)
            {
                tok = scanner.Scan(TokenType.TYPE); // Terminal Rule: TYPE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.TYPE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TYPE.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ASSIGN, TokenType.SQUAREOPEN, TokenType.BRACEOPEN, TokenType.BRACKETOPEN, TokenType.EOS); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.ASSIGN:
                case TokenType.SQUAREOPEN:
                case TokenType.BRACEOPEN:
                case TokenType.BRACKETOPEN:
                    tok = scanner.LookAhead(TokenType.ASSIGN, TokenType.SQUAREOPEN, TokenType.BRACEOPEN, TokenType.BRACKETOPEN); // Option Rule
                    if (tok.Type == TokenType.ASSIGN
                        || tok.Type == TokenType.SQUAREOPEN
                        || tok.Type == TokenType.BRACEOPEN
                        || tok.Type == TokenType.BRACKETOPEN)
                    {
                        tok = scanner.LookAhead(TokenType.ASSIGN, TokenType.SQUAREOPEN, TokenType.BRACEOPEN, TokenType.BRACKETOPEN); // Choice Rule
                        switch (tok.Type)
                        { // Choice Rule
                            case TokenType.ASSIGN:
                                ParseAssigment(node); // NonTerminal Rule: Assigment
                                break;
                            case TokenType.SQUAREOPEN:
                            case TokenType.BRACEOPEN:
                                ParseProperty(node); // NonTerminal Rule: Property
                                break;
                            case TokenType.BRACKETOPEN:
                                ParseMethod(node); // NonTerminal Rule: Method
                                break;
                            default:
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected ASSIGN, SQUAREOPEN, BRACEOPEN, or BRACKETOPEN.", 0x0002, tok));
                                break;
                        } // Choice Rule
                    }
                    break;
                case TokenType.EOS:
                    tok = scanner.Scan(TokenType.EOS); // Terminal Rule: EOS
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.EOS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOS.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected ASSIGN, SQUAREOPEN, BRACEOPEN, BRACKETOPEN, or EOS.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Declaration

        private void ParseAssigment(ParseNode parent) // NonTerminalSymbol: Assigment
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Assigment), "Assigment");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ASSIGN); // Terminal Rule: ASSIGN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ASSIGN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.ANYTHING); // Terminal Rule: ANYTHING
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ANYTHING) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ANYTHING.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOS); // Terminal Rule: EOS
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOS.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Assigment

        private void ParseProperty(ParseNode parent) // NonTerminalSymbol: Property
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Property), "Property");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.SQUAREOPEN); // Option Rule
            if (tok.Type == TokenType.SQUAREOPEN)
            {
                ParseTypedIndexer(node); // NonTerminal Rule: TypedIndexer
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACEOPEN); // Terminal Rule: BRACEOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACEOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACEOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            do { // OneOrMore Rule

                 // Concat Rule
                tok = scanner.Scan(TokenType.PROPERTY_KEYWORD); // Terminal Rule: PROPERTY_KEYWORD
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PROPERTY_KEYWORD) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PROPERTY_KEYWORD.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseCodeBlock(node); // NonTerminal Rule: CodeBlock
                tok = scanner.LookAhead(TokenType.PROPERTY_KEYWORD); // OneOrMore Rule
            } while (tok.Type == TokenType.PROPERTY_KEYWORD); // OneOrMore Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACECLOSE); // Terminal Rule: BRACECLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACECLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACECLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Property

        private void ParseTypedIndexer(ParseNode parent) // NonTerminalSymbol: TypedIndexer
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TypedIndexer), "TypedIndexer");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.SQUAREOPEN); // Terminal Rule: SQUAREOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQUAREOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUAREOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseTypedParameter(node); // NonTerminal Rule: TypedParameter

             // Concat Rule
            tok = scanner.Scan(TokenType.SQUARECLOSE); // Terminal Rule: SQUARECLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQUARECLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUARECLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: TypedIndexer

        private void ParseMethod(ParseNode parent) // NonTerminalSymbol: Method
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Method), "Method");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseParamDeclarations(node); // NonTerminal Rule: ParamDeclarations

             // Concat Rule
            ParseCodeBlock(node); // NonTerminal Rule: CodeBlock

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Method

        private void ParseCodeBlock(ParseNode parent) // NonTerminalSymbol: CodeBlock
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CodeBlock), "CodeBlock");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BRACEOPEN); // Terminal Rule: BRACEOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACEOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACEOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseStatements(node); // NonTerminal Rule: Statements

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACECLOSE); // Terminal Rule: BRACECLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACECLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACECLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CodeBlock

        private void ParseStatements(ParseNode parent) // NonTerminalSymbol: Statements
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statements), "Statements");
            parent.Nodes.Add(node);

            do { // OneOrMore Rule
                ParseStatement(node); // NonTerminal Rule: Statement
                tok = scanner.LookAhead(TokenType.LINECOMMENT, TokenType.FOREACH_LOOP, TokenType.FOR_LOOP, TokenType.IF_CONDITION, TokenType.ANYTHING, TokenType.EOS); // OneOrMore Rule
            } while (tok.Type == TokenType.LINECOMMENT
                || tok.Type == TokenType.FOREACH_LOOP
                || tok.Type == TokenType.FOR_LOOP
                || tok.Type == TokenType.IF_CONDITION
                || tok.Type == TokenType.ANYTHING
                || tok.Type == TokenType.EOS); // OneOrMore Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Statements

        private void ParseStatement(ParseNode parent) // NonTerminalSymbol: Statement
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statement), "Statement");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.LINECOMMENT, TokenType.FOREACH_LOOP, TokenType.FOR_LOOP, TokenType.IF_CONDITION, TokenType.ANYTHING, TokenType.EOS); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.LINECOMMENT:
                    tok = scanner.Scan(TokenType.LINECOMMENT); // Terminal Rule: LINECOMMENT
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.LINECOMMENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LINECOMMENT.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.FOREACH_LOOP:
                    ParseForeachStatement(node); // NonTerminal Rule: ForeachStatement
                    break;
                case TokenType.FOR_LOOP:
                    ParseForStatement(node); // NonTerminal Rule: ForStatement
                    break;
                case TokenType.IF_CONDITION:
                    ParseIfStatement(node); // NonTerminal Rule: IfStatement
                    break;
                case TokenType.ANYTHING:
                case TokenType.EOS:
                    ParseSimpleStatement(node); // NonTerminal Rule: SimpleStatement
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected LINECOMMENT, FOREACH_LOOP, FOR_LOOP, IF_CONDITION, ANYTHING, or EOS.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Statement

        private void ParseParamDeclarations(ParseNode parent) // NonTerminalSymbol: ParamDeclarations
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParamDeclarations), "ParamDeclarations");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.TYPE); // ZeroOrMore Rule
            while (tok.Type == TokenType.TYPE)
            {

                 // Concat Rule
                ParseTypedParameter(node); // NonTerminal Rule: TypedParameter

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.COMMA); // Option Rule
                if (tok.Type == TokenType.COMMA)
                {
                    tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMMA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                        return;
                    }
                }
            tok = scanner.LookAhead(TokenType.TYPE); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ParamDeclarations

        private void ParseTypedParameter(ParseNode parent) // NonTerminalSymbol: TypedParameter
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TypedParameter), "TypedParameter");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.TYPE); // Terminal Rule: TYPE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TYPE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TYPE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: TypedParameter

        private void ParseSimpleStatement(ParseNode parent) // NonTerminalSymbol: SimpleStatement
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SimpleStatement), "SimpleStatement");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.ANYTHING); // ZeroOrMore Rule
            while (tok.Type == TokenType.ANYTHING)
            {
                tok = scanner.Scan(TokenType.ANYTHING); // Terminal Rule: ANYTHING
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ANYTHING) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ANYTHING.ToString(), 0x1001, tok));
                    return;
                }
            tok = scanner.LookAhead(TokenType.ANYTHING); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOS); // Terminal Rule: EOS
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOS.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: SimpleStatement

        private void ParseIfStatement(ParseNode parent) // NonTerminalSymbol: IfStatement
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.IfStatement), "IfStatement");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IF_CONDITION); // Terminal Rule: IF_CONDITION
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IF_CONDITION) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF_CONDITION.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACEOPEN); // Option Rule
            if (tok.Type == TokenType.BRACEOPEN)
            {
                ParseCodeBlock(node); // NonTerminal Rule: CodeBlock
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: IfStatement

        private void ParseForeachStatement(ParseNode parent) // NonTerminalSymbol: ForeachStatement
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForeachStatement), "ForeachStatement");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.FOREACH_LOOP); // Terminal Rule: FOREACH_LOOP
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOREACH_LOOP) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOREACH_LOOP.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACEOPEN); // Option Rule
            if (tok.Type == TokenType.BRACEOPEN)
            {
                ParseCodeBlock(node); // NonTerminal Rule: CodeBlock
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ForeachStatement

        private void ParseForStatement(ParseNode parent) // NonTerminalSymbol: ForStatement
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForStatement), "ForStatement");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.FOR_LOOP); // Terminal Rule: FOR_LOOP
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOR_LOOP) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR_LOOP.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACEOPEN); // Option Rule
            if (tok.Type == TokenType.BRACEOPEN)
            {
                ParseCodeBlock(node); // NonTerminal Rule: CodeBlock
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ForStatement


    }

    #endregion Parser
}
